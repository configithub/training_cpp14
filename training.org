* <2016-10-10 Mon>
** rvalue
*** defintion
  - a lvalue is something that has an address in memory : we can obtain the
  address with &. It can be at either side of an = operation.
  - an rvalue is not a lvalue : we can't obtain the adress. It can only be at
    the right side of an = operation.
      Example : x*y is a rvalue

*** rvalue reference
   - if X is a type, X& is a reference and X&& is an rvalue reference.
   - This type of reference can be used to define a special type of 
     = operator, which makes a swap (or move) instead of a copy of the
     member(s) object(s) of our type.
      Example:  
            X& X::operator=(X const & rhs); // classical assign
            X& X::operator=(X&& rhs);       // rvalue ref assign
   - to obtain the rvalue ref of an object x, use std::move(x)
      Example:
        y = x;  // uses classical assign
        y = std::move(x) // uses rvalue ref assign
* <2016-10-11 Tue>
** principles
*** standard lib holy trinity : algo (sort, find..) / container / iterator
    It's easy to change the container without touching the algo function :
    sort and find work for any container. Data-centric programming.

*** c++14 = c++11 + some small stuff
    c++11 partial support : gcc4.6
    c++14 full support : gcc5.0

** new features that replace old stuff
*** types
    use explicit types : #include <cstdint> 
        std::uint8_t x;

*** typedef can be replaced by using
    using a_ptr = a*;
    using vec_double = std::vector<double>;
    template<typename T> using my_vac = std::vector<T, allocator(T)>;

*** NULL is a int, use nullptr instead
    nullptr is a pointer of type std::nullptr_t

*** new constructor call syntax to avoid ambiguity with functions
    int x{1}; // instead of int x(1);
    struct members can be given default values with this syntax
    std::vector< std::vector< int > > = { { 1, 2} , {1, 2} } // works

*** godbolt : gives the assembly version of some code
    gcc.godbolt.org

*** constructor can call another constructor
    myclass(int i, std::string s);
    myclass(int i) : myclass{2, std::string("truc")} {}

** new keywords

*** explicit keyword
    explicit myclass(std:string s); // no implicit calls 
    implies :
    myclass("truc"); // can't be used : no implicit conversion

*** prevent copy : delete keyword
    copy_constructor(const mytype&) = delete;
    instead of rendering the copy constructor private
      
    use default constructor :
    copy_constructor(const mytype&) = default;

*** use getline instead of cin on a string
    getline(std::cin, my_string);

*** type inference
**** auto keyword
     std::vector<std::string> choices{ "resto1", "resto2", "resto3" };
     for(auto& c : choices) {
     std::cout << "#" << i << " " << c << std::endl;
     }

     auto it = my_map.find(key);
     auto it = my_map.begin();
     auto it = my_map.cbegin(); // const

     The type is deduced at compile time.
     Be careful with references vs copy and constness.

**** typeid
     std::vector<int> var;
     typeid(var); // returns the type of var
     typeid(var).name();
          
**** decltype
     std::vector<int> var;
     decltype(var) vtype;
      get the type of variable, can then be reused with the using keyword
     using my_type = vtype;
     my_type var2; // another vector<int>

*** override keyword
    to force the override of a virtual function, despite change in the
    signature with the const keyword.

*** big number separator 
    int val = 1'000'000;

*** string literals
    utf8 : u8, utf16 : u, utf32 : U, raw string : R
    example utf-8 string :
    u8"blabla"
    raw string : no escape chars, useful for regexp

** lambda and function pointers
*** lambda expression
    generally used to declare a function inplace :
    std::vector<std::pair<int, std::string>> v;
    std::sort(v.begin(), v.end(), [](const auto& left, const auto& right) {
                        return left.first < right.first;});
    lambda expression syntax :
    [varcapture](args) -> ret_type { definition };

*** lambda as function pointers
    auto plus = [](int a, int b) -> int { return a+b; }

    using func_ptr = int(*)(int, int);     // classic function pointer
    using lambda_ptr = +[](int, int) -> int; // lambda exp pointer

*** std::function
    helper for function pointer, can be a function pointer or a lambda pointer 
    std::function<int(int,int)> func_ptr;

** for ranged loops
*** transform, accumulate, find, find_if
    use them instead of for loops everywhere

*** for loop on a range
    for(const auto& e : v) { }
    for(auto& e : v) { }

** libfmt : replaces iostream (not standard)
** containers
*** enum class
    enum class temperature {
    cold, hot }
    temperature x = temperature::cold;

*** std::deque : like a vector by blocks
    vector list hybrid : push possible at both end without full copy
    better then list in nearly any situation, except when iterator invalidation
    really can't happen : in this case use a list

*** std::array : like a constant vector on the stack
    no reallocation, allocation on the stack

*** std::unordered_map : much faster than map
    hash function can be defined

*** boost flat_map
    flat_set 
    map or set with data locality, insert can cost a lot 

*** boost small vector :
    start on the stack, if something is pushed realloc on the heap



